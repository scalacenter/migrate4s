<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>SemanticTree · Scalafix</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Source:"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="SemanticTree · Scalafix"/><meta property="og:type" content="website"/><meta property="og:url" content="https://scalacenter.github.io//scalafix/index.html"/><meta property="og:description" content="Source:"/><meta property="og:image" content="https://scalacenter.github.io//scalafix/img/scalafix-brand-small2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://scalacenter.github.io//scalafix/img/scalafix-brand-small2x.png"/><link rel="shortcut icon" href="/scalafix/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><script src="/scalafix/js/scrollSpy.js"></script><link rel="stylesheet" href="/scalafix/css/main.css"/><script src="/scalafix/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/scalafix/"><img class="logo" src="/scalafix/img/scalafix-brand-small2x.png" alt="Scalafix"/><h2 class="headerTitleWithLogo">Scalafix</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/scalafix/docs/users/installation.html" target="_self">User guide</a></li><li class="siteNavGroupActive"><a href="/scalafix/docs/developers/setup.html" target="_self">Developer guide</a></li><li class=""><a href="https://scalameta.org/metabrowse/#/scalafix/scalafix-core/src/main/scala/scalafix/patch/Patch.scala" target="_blank">Browse sources</a></li><li class=""><a href="https://github.com/scalacenter/scalafix" target="_blank">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>API Reference</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Implementing rules</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/setup.html">Setup</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/before-you-begin.html">Before you write code</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/tutorial.html">Tutorial</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/local-rules.html">Local rules</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/cross-publish-custom-rules.html">Cross publish custom rules</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API Reference</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/api.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/patch.html">Patch</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/symbol-matcher.html">SymbolMatcher</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/symbol-information.html">SymbolInformation</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/semantic-type.html">SemanticType</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/scalafix/docs/developers/semantic-tree.html">SemanticTree</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Contributing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/contributing.html">Guide</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/scalacenter/scalafix/edit/main/docs/developers/semantic-tree.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">SemanticTree</h1></header><article><div><span><p>Source:
<a href="https://scalameta.org/metabrowse/#/scalafix/scalafix-core/src/main/scala/scalafix/v1/SemanticTree.scala" target="_blank">
<code>SemanticTree.scala</code> </a></p>
<p><code>SemanticTree</code> is a sealed data structure that encodes tree nodes that are
generated by the compiler from inferred type parameters, implicit arguments,
implicit conversions, inferred <code>.apply</code> and for-comprehensions.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemanticTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Serializable</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span></span>: <span class="hljs-type">String</span> = <span class="hljs-type">Pretty</span>.pretty(<span class="hljs-keyword">this</span>).render(<span class="hljs-number">80</span>)
  <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span></span>(width: <span class="hljs-type">Int</span>): <span class="hljs-type">String</span> = <span class="hljs-type">Pretty</span>.pretty(<span class="hljs-keyword">this</span>).render(width)
  <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEmpty</span></span>: <span class="hljs-type">Boolean</span> = <span class="hljs-keyword">this</span> == <span class="hljs-type">NoTree</span>
  <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nonEmpty</span></span>: <span class="hljs-type">Boolean</span> = !isEmpty
}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdTree</span>(<span class="hljs-params">info: <span class="hljs-type">SymbolInformation</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span> </span>{ <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">symbol</span></span>: <span class="hljs-type">Symbol</span> = info.symbol }
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectTree</span>(<span class="hljs-params">qualifier: <span class="hljs-type">SemanticTree</span>, id: <span class="hljs-type">IdTree</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplyTree</span>(<span class="hljs-params">function: <span class="hljs-type">SemanticTree</span>, arguments: <span class="hljs-type">List</span>[<span class="hljs-type">SemanticTree</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeApplyTree</span>(<span class="hljs-params">function: <span class="hljs-type">SemanticTree</span>, typeArguments: <span class="hljs-type">List</span>[<span class="hljs-type">SemanticType</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionTree</span>(<span class="hljs-params">parameters: <span class="hljs-type">List</span>[<span class="hljs-type">IdTree</span>], body: <span class="hljs-type">SemanticTree</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiteralTree</span>(<span class="hljs-params">constant: <span class="hljs-type">Constant</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacroExpansionTree</span>(<span class="hljs-params">beforeExpansion: <span class="hljs-type">SemanticTree</span>, tpe: <span class="hljs-type">SemanticType</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OriginalSubTree</span>(<span class="hljs-params">tree: scala.meta.<span class="hljs-type">Tree</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OriginalTree</span>(<span class="hljs-params">tree: scala.meta.<span class="hljs-type">Tree</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NoTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="cookbook"></a><a href="#cookbook" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cookbook</h2>
<p>All code examples in this document assume you have the following imports in
scope</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scalafix.v1._
<span class="hljs-keyword">import</span> scala.meta._
</code></pre>
<p>The variable <code>doc</code> in the code examples is an implicit instance of
<code>scalafix.v1.SemanticDoc</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="look-up-inferred-type-parameter"></a><a href="#look-up-inferred-type-parameter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Look up inferred type parameter</h3>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Option</span>.apply(<span class="hljs-number">1</span>) <span class="hljs-comment">// inferred type parameter</span>
</code></pre>
<p>Use <code>Tree.synthetic</code> on the qualifier <code>Option.apply</code> to get the inferred type
parameters</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-comment">// Option.apply</span>
  <span class="hljs-keyword">case</span> option @ <span class="hljs-type">Term</span>.<span class="hljs-type">Select</span>(<span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"Option"</span>), <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"apply"</span>)) =&gt;
    println(<span class="hljs-string">"synthetic = "</span> + option.synthetics)
    println(<span class="hljs-string">"structure = "</span> + option.synthetics.structure)
}
<span class="hljs-comment">// synthetic = List(*[Int])</span>
<span class="hljs-comment">// structure = List(</span>
<span class="hljs-comment">//   TypeApplyTree(</span>
<span class="hljs-comment">//     OriginalTree(Term.Select(Term.Name("Option"), Term.Name("apply"))),</span>
<span class="hljs-comment">//     List(TypeRef(NoType, Symbol("scala/Int#"), List()))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>The asterisk <code>*</code> represents an <code>OriginalTree</code> node that matches the enclosing
non-synthetic tree, which is <code>List</code> in this example.</p>
<p>The <code>.synthetics</code> method is only available on <code>Term</code> nodes, using the method on
other tree nodes such as types results in compilation error</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> app @ <span class="hljs-type">Type</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"App"</span>) =&gt;
    println(<span class="hljs-string">".synthetic = "</span> + app.synthetics)
}
<span class="hljs-comment">// error: value synthetics is not a member of scala.meta.Type.Name</span>
<span class="hljs-comment">//     println(".synthetic = " + app.synthetics)</span>
<span class="hljs-comment">//                               ^^^^^^^^^^^^^^</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="look-up-symbol-of-semantic-tree"></a><a href="#look-up-symbol-of-semantic-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Look up symbol of semantic tree</h3>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> add: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> = _ + <span class="hljs-number">1</span>
add(<span class="hljs-number">2</span>)         <span class="hljs-comment">// inferred: add.apply(2)</span>
<span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">2</span>) <span class="hljs-comment">// inferred: Option.apply[Int](2)</span>
</code></pre>
<p>Use <code>Tree.synthetics</code> in combination with <code>SemanticTree.symbol</code> to get the symbol
of those inferred <code>.apply</code> method calls.</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>.<span class="hljs-type">After_4_6_0</span>(add @ <span class="hljs-string">q"add"</span>, <span class="hljs-type">Term</span>.<span class="hljs-type">ArgClause</span>(<span class="hljs-type">List</span>(<span class="hljs-string">q"2"</span>), _)) =&gt;
    println(<span class="hljs-string">"add(2)"</span>)
    println(<span class="hljs-string">"synthetic = "</span> + add.synthetics)
    println(<span class="hljs-string">"symbol    = "</span> + add.synthetics.flatMap(_.symbol).structure)
    println(<span class="hljs-string">"structure = "</span> + add.synthetics.structure)
  <span class="hljs-keyword">case</span> <span class="hljs-type">Term</span>.<span class="hljs-type">ApplyType</span>.<span class="hljs-type">After_4_6_0</span>(option @ <span class="hljs-string">q"Option"</span>, <span class="hljs-type">Term</span>.<span class="hljs-type">ArgClause</span>(<span class="hljs-type">List</span>(<span class="hljs-string">t"Int"</span>), _)) =&gt;
    println(<span class="hljs-string">"Option[Int]"</span>)
    println(<span class="hljs-string">"synthetic = "</span> + option.synthetics)
    println(<span class="hljs-string">"symbol    = "</span> + option.synthetics.flatMap(_.symbol).structure)
    println(<span class="hljs-string">"structure = "</span> + option.synthetics.structure)
}
<span class="hljs-comment">// add(2)</span>
<span class="hljs-comment">// synthetic = List(*.apply)</span>
<span class="hljs-comment">// symbol    = List(Symbol("scala/Function1#apply()."))</span>
<span class="hljs-comment">// structure = List(</span>
<span class="hljs-comment">//   SelectTree(</span>
<span class="hljs-comment">//     OriginalTree(Term.Name("add")),</span>
<span class="hljs-comment">//     IdTree(SymbolInformation(scala/Function1#apply(). =&gt; abstract method apply(v1: T1): R))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>The <code>.symbol</code> method returns nothing for the following semantic trees</p>
<ul>
<li><code>MacroExpansionTree</code></li>
<li><code>LiteralTree</code></li>
<li><code>FunctionTree</code></li>
<li><code>NoTree</code></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="look-up-implicit-argument"></a><a href="#look-up-implicit-argument" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Look up implicit argument</h3>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>.<span class="hljs-type">Implicits</span>.global
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">Future</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(<span class="hljs-keyword">implicit</span> message: <span class="hljs-type">String</span>) = println(message)
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> message = <span class="hljs-string">"hello world"</span>

<span class="hljs-type">Future</span>.apply[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>) <span class="hljs-comment">// implicit argument: global</span>
<span class="hljs-type">Main</span>.run             <span class="hljs-comment">// implicit argument: message</span>
</code></pre>
<p>Use <code>Tree.synthetics</code> to look up an implicit argument for any <code>Term</code> node.</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> term: <span class="hljs-type">Term</span> <span class="hljs-keyword">if</span> term.synthetics.nonEmpty =&gt;
    println(<span class="hljs-string">"term      = "</span> + term.syntax)
    println(<span class="hljs-string">"synthetics = "</span> + term.synthetics)
    println(<span class="hljs-string">"structure = "</span> + term.synthetics.structure)
}
<span class="hljs-comment">// term      = Future.apply[Int](3)</span>
<span class="hljs-comment">// synthetics = List(*(global))</span>
<span class="hljs-comment">// structure = List(</span>
<span class="hljs-comment">//   ApplyTree(</span>
<span class="hljs-comment">//     OriginalTree(Term.Apply(</span>
<span class="hljs-comment">//       Term.ApplyType(</span>
<span class="hljs-comment">//         Term.Select(Term.Name("Future"), Term.Name("apply")),</span>
<span class="hljs-comment">//         Type.ArgClause(List(Type.Name("Int")))</span>
<span class="hljs-comment">//       ),</span>
<span class="hljs-comment">//       Term.ArgClause(List(Lit.Int(3)), None)</span>
<span class="hljs-comment">//     )),</span>
<span class="hljs-comment">//     List(</span>
<span class="hljs-comment">//       IdTree(SymbolInformation(scala/concurrent/ExecutionContext.Implicits.global(). =&gt; final implicit method global: ExecutionContext))</span>
<span class="hljs-comment">//     )</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
<span class="hljs-comment">// term      = Main.run</span>
<span class="hljs-comment">// synthetics = List(*(message))</span>
<span class="hljs-comment">// structure = List(</span>
<span class="hljs-comment">//   ApplyTree(</span>
<span class="hljs-comment">//     OriginalTree(Term.Select(Term.Name("Main"), Term.Name("run"))),</span>
<span class="hljs-comment">//     List(</span>
<span class="hljs-comment">//       IdTree(SymbolInformation(_empty_/Main.message. =&gt; implicit val method message: String))</span>
<span class="hljs-comment">//     )</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="look-up-inferred-type-parameters-for-infix-operators"></a><a href="#look-up-inferred-type-parameters-for-infix-operators" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Look up inferred type parameters for infix operators</h3>
<p>Infix operators such as <code>a ++ b</code> can have type parameters like <code>a ++[Int] b</code>.
Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">List</span>(<span class="hljs-number">1</span>) ++ <span class="hljs-type">List</span>(<span class="hljs-number">2</span>)
</code></pre>
<p>Use the <code>Term.ApplyInfix.syntheticOperators</code> to look up inferred type parameters
of infix operators.</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> concat @ <span class="hljs-type">Term</span>.<span class="hljs-type">ApplyInfix</span>.<span class="hljs-type">After_4_6_0</span>(_, <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"++"</span>), _, _) =&gt;
    println(<span class="hljs-string">".syntheticOperators = "</span> + concat.syntheticOperators)
    println(<span class="hljs-string">".structure         = "</span> + concat.syntheticOperators.structure)
}
<span class="hljs-comment">// .syntheticOperators = List(*[Int])</span>
<span class="hljs-comment">// .structure         = List(</span>
<span class="hljs-comment">//   TypeApplyTree(</span>
<span class="hljs-comment">//     OriginalTree(Term.ApplyInfix(</span>
<span class="hljs-comment">//       Term.Apply(Term.Name("List"), Term.ArgClause(List(Lit.Int(1)), None)),</span>
<span class="hljs-comment">//       Term.Name("++"),</span>
<span class="hljs-comment">//       Type.ArgClause(List()),</span>
<span class="hljs-comment">//       Term.ArgClause(</span>
<span class="hljs-comment">//         List(</span>
<span class="hljs-comment">//           Term.Apply(Term.Name("List"), Term.ArgClause(List(Lit.Int(2)), None))</span>
<span class="hljs-comment">//         ),</span>
<span class="hljs-comment">//         None</span>
<span class="hljs-comment">//       )</span>
<span class="hljs-comment">//     )),</span>
<span class="hljs-comment">//     List(TypeRef(NoType, Symbol("scala/Int#"), List()))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>The <code>.syntheticOperators</code> method is only available for <code>Term.ApplyInfix</code> nodes,
using the method on other node types results in a compilation error</p>
<pre><code class="hljs">doc.tree.traverse {
  <span class="hljs-keyword">case</span> <span class="hljs-built_in">concat</span> @ Term.Name(<span class="hljs-string">"++"</span>) =&gt;
    <span class="hljs-built_in">println</span>(<span class="hljs-string">".syntheticOperator = "</span> + <span class="hljs-built_in">concat</span>.syntheticOperator)
}
</code></pre>
<p>Beware that looking up synthetics for the infix operator name returns nothing</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> concat @ <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"++"</span>) =&gt;
    println(<span class="hljs-string">".synthetics = "</span> + concat.synthetics)
}
<span class="hljs-comment">// .synthetics = List()</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="look-up-for-comprehension-desugaring"></a><a href="#look-up-for-comprehension-desugaring" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Look up <code>for</code> comprehension desugaring</h3>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> numbers = <span class="hljs-keyword">for</span> {
  i &lt;- <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
  j &lt;- <span class="hljs-number">1.</span>to(i)
} <span class="hljs-keyword">yield</span> i + j
<span class="hljs-keyword">for</span> (number &lt;- numbers) println(number)
</code></pre>
<p>Use <code>Tree.synthetics</code> on the tree node <code>Term.ForYield</code> to inspect the desugared
version of the <code>for { .. } yield</code> expression</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> forYield: <span class="hljs-type">Term</span>.<span class="hljs-type">ForYield</span> =&gt;
    println(<span class="hljs-string">".synthetics = "</span> + forYield.synthetics)
}
<span class="hljs-comment">// .synthetics = List(orig(List(1, 2)).flatMap[Int](</span>
<span class="hljs-comment">//   { (i) =&gt; orig(1.to(i)).map[Int]({ (j) =&gt; orig(i + j) }) }</span>
<span class="hljs-comment">// ))</span>
</code></pre>
<p>The <code>orig(List(1, 2))</code> and <code>orig(1.to(i)</code> parts represent <code>OriginalSubTree</code>
nodes that match non-synthetic tree nodes from the original for-comprehension.</p>
<h2><a class="anchor" aria-hidden="true" id="known-limitations"></a><a href="#known-limitations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Known limitations</h2>
<p>The <code>SemanticTree</code> data structure does not encode all possible synthetic code
that may get generated at compile-time. See
<a href="https://github.com/scalameta/scalameta/issues/1711">scalameta/scalameta#1711</a>
if you are interested in contributing to improve the situation.</p>
<h3><a class="anchor" aria-hidden="true" id="for-patterns"></a><a href="#for-patterns" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>for</code> patterns</h3>
<p>For comprehensions that use patterns produce incomplete semantic trees.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">for</span> {
  (a, b) &lt;- <span class="hljs-type">List</span>(<span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span>) <span class="hljs-comment">// pattern</span>
} <span class="hljs-keyword">yield</span> a + b
</code></pre>
<p>Observe the empty <code>withFilter</code> body and <code>&lt;unknown&gt;</code> parameter symbol.</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> forYield: <span class="hljs-type">Term</span>.<span class="hljs-type">ForYield</span> =&gt;
    println(forYield.synthetics)
}
<span class="hljs-comment">// List(</span>
<span class="hljs-comment">//   orig(List(1 -&gt; 2)).withFilter(</span>
<span class="hljs-comment">//     { (check$ifrefutable$1) =&gt;</span>
<span class="hljs-comment">//       </span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   ).map[Int](</span>
<span class="hljs-comment">//     { (&lt;unknown&gt;) =&gt;</span>
<span class="hljs-comment">//       </span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="for-assignments"></a><a href="#for-assignments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>for</code> assignments</h3>
<p>For comprehensions that use assignments produce incomplete semantic trees.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">for</span> {
  a &lt;- <span class="hljs-type">List</span>(<span class="hljs-number">1</span>)
  b = a + <span class="hljs-number">1</span> <span class="hljs-comment">// assignment</span>
} <span class="hljs-keyword">yield</span> a + b
</code></pre>
<p>Observe the <code>&lt;unknown&gt;</code> parameter symbol to the final call to <code>map</code>.</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> forYield: <span class="hljs-type">Term</span>.<span class="hljs-type">ForYield</span> =&gt;
    println(forYield.synthetics)
}
<span class="hljs-comment">// List(</span>
<span class="hljs-comment">//   orig(List(1)).map[Tuple2[Int,Int]](</span>
<span class="hljs-comment">//     { (a) =&gt;</span>
<span class="hljs-comment">//       orig(b = a + 1)</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   ).map[Int](</span>
<span class="hljs-comment">//     { (&lt;unknown&gt;) =&gt;</span>
<span class="hljs-comment">//       orig(a + b)</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="macros"></a><a href="#macros" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Macros</h3>
<p>Macros can expand into arbitrary code including new definitions such as methods
and classes. Semantic trees only encode tree nodes that are generated by the
compiler through offical language features like type inference and implicit
search.</p>
<h2><a class="anchor" aria-hidden="true" id="semanticdb"></a><a href="#semanticdb" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SemanticDB</h2>
<p>The structure of <code>SemanticTree</code> mirrors SemanticDB <code>Tree</code>. Consult the
SemanticDB specification for more details about synthetics:</p>
<ul>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#type">General trees</a></li>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#java-tree">Scala trees</a></li>
</ul>
<p>The <code>SemanticTree</code> data structure diverges from SemanticDB <code>Tree</code> in few minor
details.</p>
<h3><a class="anchor" aria-hidden="true" id="semantictree-instead-of-tree"></a><a href="#semantictree-instead-of-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>SemanticTree</code> instead of <code>Tree</code></h3>
<p>Scalafix uses the name <code>SemanticTree</code> instead of <code>Tree</code> in order to avoid
ambiguous references with <code>scala.meta.Tree</code> when importing the two packages
together.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scalafix.v1._
<span class="hljs-keyword">import</span> scala.meta._
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="originaltree-vs-originalsubtree"></a><a href="#originaltree-vs-originalsubtree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>OriginalTree</code> vs. <code>OriginalSubTree</code></h3>
<p>Scalafix has two kinds of original trees, <code>OriginalTree</code> and <code>OriginalSubTree</code>,
while the SemanticDB specification has only one <code>OriginalTree</code>. The difference
between the two is that</p>
<ul>
<li><code>OriginalTree</code> represents synthetic trees whose range match exactly the
enclosing <code>Synthetic</code> range.</li>
<li><code>OriginalSubTree</code> represents trees whose range is smaller than the enclosing
<code>Synthetic</code> range.</li>
</ul>
<p>This change avoids the need for the SemanticDB <code>Synthetic</code> type.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/scalafix/docs/developers/semantic-type.html"><span class="arrow-prev">← </span><span class="function-name-prevnext">SemanticType</span></a><a class="docs-next button" href="/scalafix/docs/developers/contributing.html"><span>Guide</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#cookbook">Cookbook</a><ul class="toc-headings"><li><a href="#look-up-inferred-type-parameter">Look up inferred type parameter</a></li><li><a href="#look-up-symbol-of-semantic-tree">Look up symbol of semantic tree</a></li><li><a href="#look-up-implicit-argument">Look up implicit argument</a></li><li><a href="#look-up-inferred-type-parameters-for-infix-operators">Look up inferred type parameters for infix operators</a></li><li><a href="#look-up-for-comprehension-desugaring">Look up <code>for</code> comprehension desugaring</a></li></ul></li><li><a href="#known-limitations">Known limitations</a><ul class="toc-headings"><li><a href="#for-patterns"><code>for</code> patterns</a></li><li><a href="#for-assignments"><code>for</code> assignments</a></li><li><a href="#macros">Macros</a></li></ul></li><li><a href="#semanticdb">SemanticDB</a><ul class="toc-headings"><li><a href="#semantictree-instead-of-tree"><code>SemanticTree</code> instead of <code>Tree</code></a></li><li><a href="#originaltree-vs-originalsubtree"><code>OriginalTree</code> vs. <code>OriginalSubTree</code></a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer" style="background-color:#15242B"><section class="sitemap"><a href="/scalafix/" class="nav-home"><img src="/scalafix/img/scalafix-brand-small2x.png" alt="Scalafix" width="52" height="52"/></a><div><h5>Docs</h5><a href="
                /scalafix/docs/users/installation.html">Get started</a><a href="
                /scalafix/docs/rules/overview.html">Rules</a><a href="
                /scalafix/docs/developers/setup.html">Extend Scalafix</a></div><div><h5>Community</h5><a href="https://discord.gg/8AHaqGx3Qj" target="_blank">Chat on Discord</a><a href="https://users.scala-lang.org/" target="_blank">Discuss on Scala Users</a></div><div><h5>More</h5><a href="https://github.com/scalacenter/scalafix" target="_blank">GitHub</a></div></section><section class="copyright">Copyright © 2024 Scala Center</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'cf575cebacff15579dd2dee010c4010f',
                indexName: 'scalafix',
                inputSelector: '#search_input_react'
              });
            </script></body></html>